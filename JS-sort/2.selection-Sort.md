# 2. Selection-Sort

选择排序

---

计算时间工具：console.time(timer) 与 console.timeEnd(timer)

### 分析

每趟从数组中选择前一趟中剩下的元素中最小的元素，放到数组索引为此趟趟数的位置上：

假设数组为：[3,0,2,4,1]。

第一趟，找到 0 为数组中最小的元素，放到数组索引为 0 的位置，[0,3,2,4,1];

第二趟，找到 1 为数组中剩下元素[3,2,4,1]中最小的元素，放到数组索引为 1 的位置，[0,1,2,4,3];

......

![图示](selection-Sort.gif)

### 示例: 

```
var arr = [84, 20, 29, 77, 5, 41, 100, 96, 90, 32, 
52, 82, 100, 95, 77, 37, 12, 92, 9, 
23, 13,61, 27, 59, 78, 74, 35, 18, 20, 
79, 44, 78, 64, 45, 58, 69, 3, 71, 87, 
30, 36, 2, 98, 51, 91, 88, 98, 16, 1, 28];
var len = arr.length;
var minIndex, temp;
console.time("排序时间");
// 比较len-1趟就行了， 因为比较完这一趟，最后一个元素就是最大的了
for (var i = 0; i < len - 1; i++) {
    minIndex = i; // 记录找到的最小元素的索引，默认为趟数索引
    for (var j = i + 1; j < len; j++) {
        if (arr[minIndex] > arr[j]) {
            minIndex = j; // 找到这一趟中的最小元素，记录索引
        }
    }
    temp = arr[i];
    arr[i] = arr[minIndex];
    arr[minIndex] = temp;
}
console.timeEnd("排序时间");
console.log('排序后：' + arr);
```

### 时间复杂度：O(n2)

### 最好最坏：O(n2) O(n2)

### 空间复杂度：O(1)

### 稳定性：不稳定（交换后，可能发生原较小在较大前面变成在较大后面的情况）